---
import "@/styles/normalize.css";
import "@/styles/palette.css";
import "@/styles/vars.css";
import "@/styles/style.css";
import "@fontsource-variable/onest";
import "@fontsource-variable/roboto-mono";

import * as PageStyled from "./Page.styled";
import Background from "./components/Background/Background.astro";
import Footer from "./components/Footer/Footer.astro";
import Menu from "./components/Menu/Menu.astro";
import LeftNav from "./components/LeftNav/LeftNav.astro";
import SplashToScrollUp from "./components/SplashToScrollUp/SplashToScrollUp.astro";
import jsonData from "@/data.json";

interface Props {
  title?: string;
}

const { title } = Astro.props;
const { base, separator } = jsonData.pageTitle;

let documentTitle = base;

if (title) documentTitle += ` ${separator} ${title}`;
---

<!-- TODO: semantica HTML -->
<html lang="en">
  <head>
    <!-- TODO: completar para el SEO -->

    <meta charset="UTF-8" />
    <meta name="description" content="Astro description" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />

    <link rel="icon" href="/favicon-logo-s.ico" />
    <title>{documentTitle}</title>
  </head>
  <body>
    <Background />
    <PageStyled.Component>
      <div class="static">
        <main>
          <slot />
        </main>
        <Footer />
      </div>
      <Menu />
      <LeftNav />
      <!-- <SplashToScrollUp /> -->
    </PageStyled.Component>
  </body>
</html>

<script is:inline src="https://kit.fontawesome.com/7463805de7.js"></script>

<script>
  import { bodyManager } from "@/tools/elementManagers.tool";
  import { darkModeEntity } from "@/services";

  const DEFAULT_DARK_MODE = true;

  const darkModeInit = () => {
    // Si existe la entidad en local storage, se la utiliza
    const darkModeValue = darkModeEntity.get();
    if (darkModeValue !== null) return darkModeValue;

    // Si existe la media del usuario, se la utiliza
    if (window.matchMedia)
      return window.matchMedia("(prefers-color-scheme: dark)").matches;

    // Si no, se crea la entidad en local storage y se la utiliza
    darkModeEntity.set(DEFAULT_DARK_MODE);
    return DEFAULT_DARK_MODE;
  };

  bodyManager.setData("darkMode", String(darkModeInit()));
</script>

<script>
  import { NOT_FONT_SIZE, getCSSVarValue } from "@/styles";
  import { bodyManager } from "@/tools/elementManagers.tool";
  import { onScreen } from "@/tools";

  const MARGIN = NOT_FONT_SIZE.m;

  let margin = getCSSVarValue(MARGIN);
  margin = margin.slice(0, -3);
  margin = `-${parseFloat(margin) * 16}px`;

  const { socialNetsInAbout } = window;

  if (socialNetsInAbout)
    onScreen({
      observed: socialNetsInAbout,
      margin,
      onIntersectionChange: (isIntersecting) => {
        bodyManager.setData("socialNetsInLeftNav", String(!isIntersecting));
      },
    });
  // Si no existe socialNetsInAbout en la página, socialNetsInLeftNav siempre será visible
  else bodyManager.setData("socialNetsInLeftNav", "true");
</script>

<script>
  import { sleep } from "@/tools";

  const elementSliders =
    document.querySelectorAll<HTMLElement>(".element-slider");

  elementSliders.forEach((elementSlider) => {
    // Selecciona todos los hijos directos <li> del slider
    const items = elementSlider.querySelectorAll<HTMLLIElement>("& > li");

    /*
      Selecciona cada contenido hijo directo de todos los hijos directos <li>
      del slider.
    */
    const observableContents = elementSlider.querySelectorAll<HTMLElement>(
      "& > li > *:first-child",
    );

    // TODO: queda pulir, todavía tiene algunos fallos al redimensionar

    let greaterHeight = 0;
    let highestContent: HTMLElement | undefined = undefined;

    observableContents.forEach((observableContent) => {
      const resizeObserver = new ResizeObserver((entries) => {
        if (entries.length > 0) {
          const contentHeight = entries[0].contentRect.height;

          /*
            Compara la altura actual con la mayor altura encontrada hasta el
            momento.
          */
          if (greaterHeight < contentHeight) {
            /*
              Si la altura actual es mayor, actualiza la referencia al
              contenido más alto.
            */
            highestContent = observableContent;
            greaterHeight = contentHeight;
          }

          // Verifica si el contenido actual es el más alto
          if (highestContent === observableContent) {
            /*
              Si es así, ajusta la altura del contenedor y de todos los
              elementos <li> asociados.
            */
            elementSlider.style.height = `${contentHeight}px`;
            items.forEach((item) => (item.style.height = `${contentHeight}px`));
          }
        }
      });

      resizeObserver.observe(observableContent);
    });
  });

  /*
    Reinicia el desplazamiento vertical del slider, corrigiendo el
    desplazamiento indeseado por el "juego" de las dimensiones.
  */
  await sleep(50);
  elementSliders.forEach((elementSlider) => (elementSlider.scrollTop = 0));
</script>

<script>
  const adaptables =
    window.document.querySelectorAll<HTMLElement>(".adaptable");

  adaptables.forEach((adaptable) => {
    const content = adaptable.querySelector("& > *");

    const resizeObserver = new ResizeObserver((entries) => {
      if (entries.length > 0) {
        const { width, height } = entries[0].contentRect;

        adaptable.style.setProperty("--content-width", `${width}px`);
        adaptable.style.setProperty("--content-height", `${height}px`);
      }
    });

    content && resizeObserver.observe(content);
  });
</script>
