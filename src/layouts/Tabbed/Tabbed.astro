---
import './Tabbed.css'

export interface Props {
  sectionTitles: string[]
  handlingClass?: string
}

const { sectionTitles, handlingClass } = Astro.props

// TODO: se podria optimizar mejor con el uso de la caracteristica de espera para el display en CSS
---

<article class:list={['tabbed', handlingClass]}>
  <header>
    <div class="nav">
      <span class="bg-indicator bg"></span>
      <fieldset>
        {
          sectionTitles.map(title => (
            <label>
              <input type="radio" name="sections" />
              {title}
            </label>
          ))
        }
      </fieldset>
    </div>
    <span class="line"></span>
  </header>
  <ol class="element-slider">
    <slot />
  </ol>
</article>

<script>
  import { $$, sleep } from '@/tools'

  const ACTIVE_CLASS = 'active'
  const INACTIVE_CLASS = 'inactive'

  const tabbeds = $$('.tabbed')

  tabbeds.forEach(tabbed => {
    const elementSlider = tabbed.querySelector<HTMLElement>('.element-slider')
    const indicator = tabbed.querySelector<HTMLElement>('.bg-indicator')

    if (elementSlider && indicator) {
      const labels = tabbed.querySelectorAll('label')
      const items = Array.from(elementSlider.querySelectorAll('& > li'))
      const radioInputs = tabbed.querySelectorAll<HTMLInputElement>(
        'input[type="radio"]'
      )

      const moveIndicator = (index: number) => {
        const label = labels[index]
        const inputRect = label.getBoundingClientRect()

        indicator.style.left = `${label.offsetLeft}px`
        indicator.style.width = `${inputRect.width}px`
      }

      // Inicializar
      items.forEach(item => item.classList.add(INACTIVE_CLASS))
      items[0].classList.remove(INACTIVE_CLASS)
      items[0].classList.add(ACTIVE_CLASS)

      radioInputs[0].checked = true
      moveIndicator(0)

      radioInputs.forEach(radioInput => {
        radioInput.addEventListener('change', () => {
          const checkedRadioInputIndex = Array.from(radioInputs).findIndex(
            input => input.checked
          )

          items.forEach(async (item, index) => {
            // TODO: Implementar la espera con el evento "transitionend" en vez de sleep

            if (index === checkedRadioInputIndex) {
              // Radio input activo

              // La duraciÃ³n debe ser la misma que las transitions CSS
              await sleep(200)

              item.classList.remove(INACTIVE_CLASS)
              item.classList.add(ACTIVE_CLASS)
            } else {
              // Radio input inactivo

              item.classList.remove(ACTIVE_CLASS)
              item.classList.add(INACTIVE_CLASS)
            }
          })

          moveIndicator(checkedRadioInputIndex)
        })
      })

      const resizeObserver = new ResizeObserver(() => {
        const maxHeight = Math.max(...items.map(item => item.clientHeight))
        elementSlider.style.height = `${maxHeight / 16}rem`
      })

      resizeObserver.observe(elementSlider)
    }
  })
</script>
